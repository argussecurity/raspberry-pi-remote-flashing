#!/usr/bin/env bash

# SPDX-License-Identifier: GPL-2.0 #
# (C) Copyright Argus Cyber Security Ltd
#  All rights reserved

#######################################################################################################################
# Script Name   :   Boot Script
# Description   :   This is an U-Boot boot script file.
#                   It executes on boot by U-Boot and load an environment file
#                   called env.txt from the MMC first partition.
#                   This env file contains the target IP address and the server address.
#                   It then tries to fetch a file from the server's TFTP
#                   from a folder named by the target MAC address.
#                   If it finds the image, it then fetch and flash it to the MMC second and third partitions.
#                   When flashing finished or a file wasn't find, and then
#                   loading the 'cmdline.txt' file from the second partition and continues to boot.
# Args          :
# Date          :   23/11/2020
# Author        :   Itay Sperling
# Email         :   itay.sperling@argus-sec.com
#######################################################################################################################

# Keep only MMC boot as a boot target - disable all other boot methods
setenv boot_targets mmc0

# enable netconsole (can be disabled if defined in env.txt as 'netconsole=0')
setenv netconsole 1

# load env file and assign some variables
load mmc 0:1 $loadaddr env.txt
env import -t $loadaddr $filesize serverip ipaddr image_name netconsole

# forward the console from serial to netconsole
if test $netconsole = '1'; then
    setenv nc 'setenv stdout serial,nc;setenv stdin serial;'
    setenv ncip $serverip
    run nc
fi

echo "==== ARGUS U-BOOT FLASHING SCRIPT ====="
# debug print assigned addresses. 
# we assigned 'serverip' and 'ipaddr' from env.txt
printenv serverip
printenv ipaddr
printenv ethaddr
echo ""

# Reset file size counter so we can later check if tftp download succeeded
setenv filesize 0

# When flashing an image we don't want to overwrite the SD first partition
# We don't want to flash the first image blocks (where the partition table is)
# We need to do calculations:
# Assuming RAM address is: 0x00080000
# We have partition table and other data from address 0 to 4194304 (dec, not hex)
# 0x00080000 + 4194304 = 0x480000
# The address of the second partition is: 0x16000

# Init values for reading the first file to RAM
setenv pt_size_bytes 400000
setenv ram_start_add_bytes 80000

# Get file from a remote tftp server, store in RAM
# server folder path is this device MAC address
tftpboot 0x${ram_start_add_bytes} ${serverip}:${ethaddr}/rpi_image_part_0

# If $filesize is greater than 0 - transfer probably completed
if test ${filesize} > 0; then 
    # Remove old version number file (generated by the Yocto build)
    # This is one indication if flash succeeded
    fatrm mmc 0:2 image-version-info

    # Calculate addresses and write first file (skipping the partition table) to MMC (SD Card)
    setenv mmc_offset 16000
    setexpr blocks_to_skip $pt_size_bytes / 200 ;
    setexpr img_size_blk $filesize / 200 ;
    setexpr blocks_to_write $img_size_blk - $blocks_to_skip ;
    setexpr ram_address_bytes $ram_start_add_bytes + $pt_size_bytes ;

    # mmc write [RAM ADDRESS bytes] [MMC BLK ADDRES] [BLK COUNT]
    mmc write 0x${ram_address_bytes} 0x${mmc_offset} 0x${blocks_to_write} ;
    setexpr mmc_offset $mmc_offset + 0x${blocks_to_write} ;
    setexpr flashed_bytes $blocks_to_write * 200

    # init values needed for the rest of the files
    setenv ram_address_bytes $ram_start_add_bytes
    setenv file_not_found false

    # Iterate over the rest of the files, read to RAM and write to mmc
    for i in 1 2 3 4 5 6 7 8 9; do
        if $file_not_found ; then
            # Skip the rest of the iterations
        else 
            setenv filesize 0
            tftpboot 0x${ram_start_add_bytes} ${serverip}:${ethaddr}/rpi_image_part_$i
            if test ${filesize} > 0 ; then
                setexpr img_size_blk $filesize / 200 ;
                mmc write 0x${ram_address_bytes} 0x${mmc_offset} 0x${img_size_blk} ;
                setexpr mmc_offset $mmc_offset + 0x${img_size_blk} ;
                setexpr flashed_bytes $flashed_bytes + $filesize ;
            else 
                setenv file_not_found true
            fi 
        fi
    done

    echo "flashed_bytes = $flashed_bytes"

    # We deleted this file before flashing, if it exists - flashing succeeded
    if fatload mmc 0:2 ${loadaddr} image-version-info; then 
        setenv status OK
    else
        setenv status FAILED
    fi

    # Load written size memory and save it as a file on TFTP server
    mw.l ${loadaddr} ${flashed_bytes}
    tftpput ${loadaddr} 4 ${serverip}:${ethaddr}/${status}
fi;

# load cmdline.txt file to memory (used foor bootcmd)
load mmc 0:2 0x00200008 cmdline.txt
## calc new filesize
setexpr cmdline_size $filesize + 8

# modify memory, add "cmdline=" before the data (else env import wont work)
mw.l 0x00200000 0x6c646d63   
mw.l 0x00200004 0x3d656e69   

# load the memory as env
env import -t 0x00200000 $cmdline_size cmdline

echo ""
echo "Original bootargs:"
printenv cmdline
echo ""

echo "substituting rootfs partition: mmcblk0p2 -> mmcblk0p3"
setexpr cmdline sub mmcblk0p2 mmcblk0p3
echo ""
echo "substituting serial output: serial0 -> ttyS0"
setexpr cmdline sub serial0 ttyS0
echo ""

# Set boot command
setenv bootargs ${cmdline} 8250.nr_uarts=1 initcall_blacklist=bcm2708_fb_init

echo "New bootargs:"
printenv bootargs
echo ""

echo "Loading DTB file:"
printenv fdtfile

# Load blobs to ram
fatload mmc 0:2 ${fdt_addr_r} ${fdtfile}
echo ""

echo "Loading Kernel image kernel7.img:"
fatload mmc 0:2 ${kernel_addr_r} kernel7.img
echo ""

echo "Booting.."
# Boot file kernel and device
bootz ${kernel_addr_r} - ${fdt_addr_r}
